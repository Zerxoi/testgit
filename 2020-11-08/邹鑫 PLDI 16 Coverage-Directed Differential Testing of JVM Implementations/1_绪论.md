# 1 绪论

Java虚拟机（JVM）是一种成熟的Java技术。JVM负责以相同的方式在任何平台上加载，链接和执行Java类文件（`.class`）。Oracle的HotSpot，IBM的J9，Jikes RVM，Azul的Zulu和GNU的GIJ等各种JVM（即JVM实现）都可以使用并且仍在不断发展。他们采用不同的实现技术（例如即时编译，提前编译和解释），并适应不同的操作系统和CPU体系结构。为了确保它们的兼容性，它们必须一致地实现单个JVM规范。

现实情况是，没有两个JVM完全相同，并且在遇到极端情况或无效的类文件时它们可能表现出差异：Java类可以在某些JVM上运行，但不能在其他JVM上运行，应用程序在某些JVM上运行时可能会受到攻击，或者JVM本身可能在运行时崩溃。例如，文本搜索引擎Lucene在来自不同供应商的JVM上运行大量错误：它在使用G1垃圾收集器在任何HotSpot版本上失败； 当Lucene在Java 6或7u1的HotSpot上运行时，`readVInt()` 返回错误的结果；当Lucene在J9上运行时，由于未正确编译的循环等，`FST.pack()`可能会产生损坏的索引。

这些JVM差异主要是在两种情况下造成的。首先，JVM实现可能包含缺陷。因为开发人员在开发各自的JVM时可能不会犯相同的错误，因此它们之间的行为可能会有所不同。在这里，我们将JVM实现中的任何编程错误（例如，空指针）或将实现与JVM规范的任何一致性冲突都视为*JVM缺陷*。尤其是，JVM具有590页的规范，该规范很全面，但仍然可能含糊不清。 该规范还保留了某些未定义的行为：“如果有某种约束（'必须'或'必须'）... 如果在运行时不满足，则Java虚拟机的行为是不确定的”（请参阅JVM规范中的§6.1）。JVM实现也可能很复杂。 例如，HotSpot有超过25万行代码。 因此，很难有一个严格符合JVM规范的JVM实现。

其次，JVM实现之间存在兼容性问题（请参阅Java语言规范的第13章）。Java应用程序，JVM实现，Java运行时环境（JRE）和平台之间也存在不匹配的情况。例如，Java本机接口(JNI)允许Java代码调用用C、C++和汇编编写的本机应用程序和库，或者被本机应用程序和库调用，而据报道，在一些情况下，HotSpot继续运行，而J9崩溃。

现在，我们将JVM的*discrepancies*和*defects*形式化，以简化我们的工作。我们将一个JVM的执行表示为`r = jvm(e, c, i)`，其中`jvm`是一个JVM的实现，`e`是执行相关的环境（包括`jvm`所依赖的JRE库和加载的类和资源），`c`和`i`分别是运行在jvm上的类和输入，`r`是`jvm`报告的可观察行为（即输出或错误）。

定义1（JVM差异）. 给定`r_1 = jvm_1(e_1，c，i)`和`r_2 = jvm_2(e_2，c，i)`，当r1和r2明显不同（表示为`r1 ≁ r2`）就会出现JVM差异，即r1和r2具有不同的输出或错误时。

如果在给定相同的类的情况下，两个JVM的行为不同，则很容易观察到差异，例如，一个声明该类可以正常运行，而另一个声明一个错误。 拒绝类文件时，JVM可能会给出不同的错误，其等效性可能需要仔细分析。 在我们的研究中，我们对执行结果进行了细粒度的分析（第2.3节中的详细信息）。

定义2（JVM缺陷）. JVM 差异是给定`r_1 = jvm_1(e_1，c，i)`和`r_2 = jvm_2(e_2，c，i)`，`r1 ≁ r2`。当jvm1和jvm2相对于同一环境运行时（即`e1 = e2`），我们将JVM差异称为JVM缺陷。

通过比较多个系统，差异测试可能是揭示JVM中缺陷的一种有前途的方法。 它通过在JVM上运行每个测试类文件来进行操作，并且任何检测到的差异（例如，一个类文件可以在一个JVM上成功运行，但不能在其他JVM上成功运行）可能表明JVM实现中存在缺陷。 但是，差异JVM测试面临两个关键挑战：

挑战1：*需要为差异JVM测试专门构建类文件。* 由于类文件可以包含复杂的句法和语义约束，因此测试工程师必须花大力气来设计测试以及他们的测试Oracle。 尽管可以将实际应用程序（例如Lucene）用于测试JVM，但它们不足以测试JVM的所有方面。 现实世界中的应用程序还由于其在应用程序，JVM和JRE之间的复杂依赖性而在复制，报告，诊断和排除JVM缺陷方面带来了困难。

另一种选择是采用二进制模糊测试，通过盲目更改种子类文件并在不同的JVM二进制文件上运行变量来对JVM进行差异测试。 这种方法允许产生大量的测试类文件，包括许多无效的和意外的文件。 但是，很容易导致大量的冗余测试，因为大多数变体会触发少量的JVM差异。

挑战2：*JVM差异很常见，但主要只涉及兼容性问题，而不是实际缺陷。* 我们已经通过在五个JVM的JRE7库中运行类文件进行了初步研究，这些JVM包括Java 7/8/9的HotSpot版本，IBM SDK8的J9版本和GIJ 5.1.0。结果表明，1.7％的类文件（共21736个中的364个）可以揭示JVM的差异。例如，类`sun.beans.editors.EnumEditor`可以在Java 8的HotSpot上触发`VerifyError`，因为其超类`com.sun.beans.editors.EnumEditor`被声明为`final`，因此在JRE8中不可子类化；在J9上运行时，由于HotSpot和J9采用不同的堆栈框架，因此37个类文件可能会触发验证错误（“堆栈形状不一致”）;当在Java 8/9，J9和GIJ的HotSpot发行版上运行时，JRE7库类文件还可以触发许多`NoClassDefFoundErrors`和`MissingResourceExceptions`，因为某些类和资源无法在运行时由这些JVM加载。

这些上述差异主要与兼容性问题有关，而不是与JVM缺陷有关。 可以通过针对特定环境强制执行JVM来消除它们（通过升级/降级JRE库或为JVM重置CLASSPATH环境变量），而不是自行修复JVM。

为了解决这些挑战，我们建议使用*classfuzz*，这是*一种覆盖率导向的模糊方法*，其重点是为JVM的启动过程的差异测试构建*代表性*的类文件。JVM启动过程涉及加载，链接，初始化和调用类的步骤（第2.1节对此进行了详细说明）。 所谓*代表性*，意思是所构造的测试类文件对于差分测试可能是不同的且唯一的，例如，它们采用不同的控制流路径，强制执行新的检查策略（的组合），或者导致新的JVM错误/异常。为此，我们在参考JVM实现上执行测试类文件，并将*覆盖唯一性*作为接受代表性文件的准则。

classfuzz的基本思想是迭代变异种子类文件并仅接受*代表性*的突变体。接受的类文件作为输入，对JVM进行差异化测试，发现缺陷。特别是，我们定义了129个变异子（mutators，变异算子），并采用*Markov Chain Monte Carlo（MCMC）*采样来指导变异子选择。 MCMC采样是一类算法，用于通过构造收敛到所需分布的马尔可夫链来从概率分布中进行采样。 它提供了解决许多棘手问题的通用解决方案，而没有精确的算法。

本文做出以下主要贡献：

1. *测试的代表性*。 我们将寻找代表性测试的难题转化为覆盖范围的唯一性问题。 这使我们可以通过在参考JVM上运行来选择确认具有代表性的那些测试。 这种高层次的观点是通用的，适用于其他有大规模软件系统和随机测试输入的场合。
2. *面向覆盖的类文件突变*。 Classfuzz提供了一种构建代表性测试类文件的实用解决方案。 如图2所示，classfuzz（1）更改种子类文件并创建尽可能多的变异，包括许多极端情况；（2）在参考JVM实现上运行变量，并使用覆盖唯一性来选择代表性的变异，以及（3） 利用MCMC采样来动态地指导变异子（mutators）选择器，因为某些变异子（mutators）在创建代表性的类文件中更有效。
3. *实现和评估*。 我们已经实现了classfuzz，并根据现有的模糊测试算法对其进行了广泛的评估。 我们的结果表明，classfuzz可以将触发差异的类文件的比例从1.7%提高到11.9%。我们还向JVM开发人员报告了许多JVM差异以及测试类文件。这些差异大多是缺陷指示性的，或者对应于JVM各自采取的检查和验证策略，我们报告的许多问题已经被确认为JVM缺陷。某些差异甚至与最近对JVM规范的Java SE 8版本的澄清和更改相符。 我们认为，classfuzz在检测JVM缺陷和提高JVM实现的鲁棒性方面是切实有效的。

本文的其余部分结构如下。 第2节介绍了classfuzz的技术细节。 第3节介绍了我们对classfuzz的广泛评估。 第4节调查相关工作，第5节总结。